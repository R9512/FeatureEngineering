import java.io.IOException;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
public class Correlation1
{

  public static class MapMethod extends Mapper<Object, Text,  IntWritable,Text>
  {

    /*
          Input: Object and Text 
          Output: IntWritable and Text
            Object      => Generated By the FrameWork
            Text        => The Actual Text
            IntWritable => The Quater To Which It Belongs
            Text        => Outputting the Float Value As the String
    */
    public void map(Object key, Text value, Context context) throws IOException, InterruptedException 
    {
      String s = value.toString();
      String[] s1 = s.split(",",-1);
      context.write(new IntWritable(Integer.parseInt(s1[1])),value);
    }
  }

  public static class ReduceMethod extends Reducer<IntWritable,Text,IntWritable,Text> 
    {
      /*
          Input: IntWritable and Text 
          Output: IntWritable and Text
            IntWritable => The Quater To Which It Belongs
            Text        => Outputting the Float Value As the String
            IntWritable => Some Dummy Varaible
            Text        => The Final Output which is used to Genreate The Final Output

          Just Creating an Array of all the Averages and Findinf out the Maximum number.
    */

    public void reduce(IntWritable key, Iterable<Text> values, Context context) throws IOException, InterruptedException 
    {
        //Generating The Final Output.....
      String s ="";
      String[] s1,s2;
      float sum = 0;
      float temp = 0;
      int count = 0,temp1 = 0;
      String all = "";
      List<Text> copy = new ArrayList<Text>();
      for(Text val : values)
      {
        s = val.toString();
        all+=s+"#";
        s1 = s.split(",",-1);
        sum+= Float.parseFloat(s1[2].toString());
        count+=1;
        copy.add(val);
      }
      temp1 = count;
      sum/=count;
      s1 = all.split("#",-1);
      for(int i=0;i<s1.length-1;i++)
      {
        s = s1[i];
        s2 = s.split(",",-1);
        temp = Float.parseFloat(s2[2].toString());
        temp -=sum;
        context.write(new IntWritable(1),new Text(","+s2[0]+","+s2[1]+","+s2[2]+","+"A,"+count));
      context.write(new IntWritable(1),new Text(","+s2[1]+","+s2[0]+","+s2[2]+","+"B,"+count));
        //context.write(new IntWritable(1),new Text(s));
      }

    }
    
  }

  public static void main(String[] args) throws Exception 
  {
    Configuration conf = new Configuration();
    Job job = Job.getInstance(conf, "ST-1");
    job.setJarByClass(Correlation1.class);
    job.setMapperClass(MapMethod.class);
    job.setReducerClass(ReduceMethod.class);
    job.setOutputValueClass(Text.class);
    job.setOutputKeyClass(IntWritable.class);
    FileInputFormat.addInputPath(job, new Path(args[0]));
    FileOutputFormat.setOutputPath(job, new Path(args[1]));
    System.exit(job.waitForCompletion(true) ? 0 : 1);
  }
}
